// ===================== CONFIG =====================
const SHEET_VIP   = "VIP";
const SHEET_CODES = "CODES";
const ADMIN_PASSWORD = "1234"; // troque

// ===================== Helpers =====================
function ss_(){ return SpreadsheetApp.getActiveSpreadsheet(); }
function sh_(name){
  const sh = ss_().getSheetByName(name);
  if(!sh) throw new Error("Aba não encontrada: " + name);
  return sh;
}
function json_(obj){
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
function now_(){ return new Date(); }
function toMs_(d){ return new Date(d).getTime(); }
function isExpired_(expiresAt){ return now_().getTime() > toMs_(expiresAt); }

function randCode_(len=6){
  const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
  let out = "";
  for(let i=0;i<len;i++) out += chars[Math.floor(Math.random()*chars.length)];
  return out;
}
function indexMap_(headers){
  const map = {};
  headers.forEach((h,i)=> map[String(h).trim()] = i);
  return map;
}
function ensureHeaders_(sheetName, headers){
  const sh = sh_(sheetName);
  if(sh.getLastRow() === 0){
    sh.getRange(1,1,1,headers.length).setValues([headers]);
    return;
  }
  const first = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0].map(String);
  const missing = headers.filter(h => !first.includes(h));
  if(missing.length){
    sh.getRange(1, sh.getLastColumn()+1, 1, missing.length).setValues([missing]);
  }
}
function vipInit_(){
  ensureHeaders_(SHEET_CODES, ["code","expiresAt","createdAt","slotsAllowed","slotsAssigned","isActive"]);
  ensureHeaders_(SHEET_VIP,   ["slot","status","nome","rg","cpf","veiculo","placa","cor","modelo","updatedAt","code","confirmed"]);
}
function checkAdmin_(adminPass){
  if(String(adminPass||"") !== String(ADMIN_PASSWORD)){
    return { ok:false, error:"Senha admin inválida." };
  }
  return { ok:true };
}

// ===================== doGet =====================
function doGet(){ return json_({ ok:true, msg:"VIP API online" }); }

// ===================== Code helpers =====================
function findCodeRow_(code){
  code = String(code||"").trim().toUpperCase();
  if(!code) return null;

  const sh = sh_(SHEET_CODES);
  if(sh.getLastRow() < 2) return null;

  const values = sh.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  for(let i=1;i<values.length;i++){
    const c = String(values[i][idx.code]||"").trim().toUpperCase();
    if(c === code){
      return { sh, rowIndex: i+1, headers, idx, row: values[i] };
    }
  }
  return null;
}

function validateCode_(code){
  const row = findCodeRow_(code);
  if(!row) return { ok:false, error:"Código inválido." };

  const exp = row.row[row.idx.expiresAt];
  if(!exp) return { ok:false, error:"Código inválido (sem validade)." };
  if(isExpired_(exp)) return { ok:false, error:"Código expirado." };

  const isActive = String(row.row[row.idx.isActive]||"TRUE").toUpperCase() !== "FALSE";
  if(!isActive) return { ok:false, error:"Código desativado." };

  const slotsAllowed  = Number(row.row[row.idx.slotsAllowed]||0);
  const slotsAssigned = Number(row.row[row.idx.slotsAssigned]||0);

  return { ok:true, code: String(code).trim().toUpperCase(), slotsAllowed, slotsAssigned };
}

// ===================== VIP Public =====================
// Agora o public enxerga SOMENTE slots com code = informado
function vipPublicGet(code){
  vipInit_();
  const chk = validateCode_(code);
  if(!chk.ok) return chk;

  const vip = sh_(SHEET_VIP);
  const values = vip.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  const slots = [];
  for(let i=1;i<values.length;i++){
    const slotCode = String(values[i][idx.code]||"").trim().toUpperCase();
    if(slotCode !== chk.code) continue;

    const status = String(values[i][idx.status]||"LIVRE").toUpperCase();
    const nome = String(values[i][idx.nome]||"");
    const confirmed = String(values[i][idx.confirmed]||"").toUpperCase()==="TRUE";

    slots.push({
      slot: values[i][idx.slot],
      status: confirmed ? "CONFIRMADO" : status,
      nomeMasked: maskName_(nome),
      codeTag: "#" + chk.code
    });
  }

  return { ok:true, slots, code: chk.code };
}

function vipReserve(code, payload){
  vipInit_();
  const chk = validateCode_(code);
  if(!chk.ok) return chk;

  const vip = sh_(SHEET_VIP);
  const values = vip.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  const slotId = String(payload.slot||"").trim();
  if(!slotId) return { ok:false, error:"Slot inválido." };

  // achar linha do slot dentro do código
  let rowIndex = -1;
  for(let i=1;i<values.length;i++){
    const slot = String(values[i][idx.slot]);
    const slotCode = String(values[i][idx.code]||"").trim().toUpperCase();
    if(slot === slotId && slotCode === chk.code){
      rowIndex = i+1;
      break;
    }
  }
  if(rowIndex<0) return { ok:false, error:"Slot não encontrado para este código." };

  const status = String(vip.getRange(rowIndex, idx.status+1).getValue()||"").toUpperCase();
  const confirmed = String(vip.getRange(rowIndex, idx.confirmed+1).getValue()||"").toUpperCase()==="TRUE";

  if(confirmed) return { ok:false, error:"Slot já confirmado." };
  if(status === "BLOQUEADO") return { ok:false, error:"Slot bloqueado." };
  if(status === "OCUPADO") return { ok:false, error:"Slot já ocupado." };

  vip.getRange(rowIndex, idx.status+1).setValue("OCUPADO");
  vip.getRange(rowIndex, idx.nome+1).setValue(payload.nome||"");
  vip.getRange(rowIndex, idx.rg+1).setValue(payload.rg||"");
  vip.getRange(rowIndex, idx.cpf+1).setValue(payload.cpf||"");

  vip.getRange(rowIndex, idx.veiculo+1).setValue(payload.veiculo ? "SIM":"NAO");
  vip.getRange(rowIndex, idx.placa+1).setValue(payload.placa||"");
  vip.getRange(rowIndex, idx.cor+1).setValue(payload.cor||"");
  vip.getRange(rowIndex, idx.modelo+1).setValue(payload.modelo||"");
  vip.getRange(rowIndex, idx.updatedAt+1).setValue(now_());

  return { ok:true };
}

// ===================== Admin: Pool (slots gerais) =====================
// total = total de slots no pool (code vazio)
// Aumentar: cria slots novos (code vazio)
// Diminuir: remove slots do pool livres de trás pra frente
function vipAdminSetGlobalSlotCount(adminPass, total){
  vipInit_();
  const a = checkAdmin_(adminPass); if(!a.ok) return a;

  total = Math.max(0, parseInt(total||0,10));

  const vip = sh_(SHEET_VIP);
  const values = vip.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  // descobrir maior número de slot já usado (global)
  let maxSlotNum = 0;
  for(let i=1;i<values.length;i++){
    const n = Number(values[i][idx.slot]||0);
    if(n > maxSlotNum) maxSlotNum = n;
  }

  // pool rows
  const pool = [];
  for(let i=1;i<values.length;i++){
    const code = String(values[i][idx.code]||"").trim();
    if(!code){
      pool.push({
        rowIndex: i+1,
        slot: String(values[i][idx.slot]||""),
        status: String(values[i][idx.status]||"").toUpperCase()
      });
    }
  }

  const current = pool.length;

  // aumentar
  if(total > current){
    const add = total - current;
    const data = [];
    for(let k=1;k<=add;k++){
      maxSlotNum++;
      data.push([String(maxSlotNum), "LIVRE","","","","NAO","","","", "", "", "FALSE"]);
    }
    vip.getRange(vip.getLastRow()+1, 1, data.length, headers.length).setValues(
      data.map(r => {
        // map na ordem dos headers existentes
        const obj = {
          slot:r[0], status:r[1], nome:r[2], rg:r[3], cpf:r[4], veiculo:r[5],
          placa:r[6], cor:r[7], modelo:r[8], updatedAt:r[9], code:r[10], confirmed:r[11]
        };
        return headers.map(h => (obj[h]!==undefined ? obj[h] : ""));
      })
    );
    return { ok:true, action:"increased", from:current, to:total, added:add };
  }

  // diminuir
  if(total < current){
    let remove = current - total;

    // pegar candidatos livres e sem code, de trás pra frente
    const candidates = pool
      .filter(p => p.status === "LIVRE")
      .sort((a,b)=> Number(b.slot)-Number(a.slot));

    if(candidates.length < remove){
      return { ok:false, error:`Não dá para reduzir: faltam slots livres no pool. Livres: ${candidates.length}, precisa remover: ${remove}.` };
    }

    // deletar linhas (sempre em ordem decrescente pra não bagunçar index)
    const rowsToDelete = candidates.slice(0, remove).map(x=>x.rowIndex).sort((a,b)=>b-a);
    rowsToDelete.forEach(r => vip.deleteRow(r));

    return { ok:true, action:"decreased", from:current, to:total, removed:remove };
  }

  return { ok:true, action:"unchanged", total };
}

// ===================== Admin: Códigos =====================
function vipAdminCreateOrUpdateCode(adminPass, minutes, slotsAllowed){
  vipInit_();
  const a = checkAdmin_(adminPass); if(!a.ok) return a;

  minutes = Math.max(1, parseInt(minutes||60,10));
  slotsAllowed = Math.max(0, parseInt(slotsAllowed||0,10));

  const code = randCode_(6);
  const expiresAt = new Date(now_().getTime() + minutes*60000);

  const sh = sh_(SHEET_CODES);
  const values = sh.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  sh.appendRow([
    code, expiresAt, now_(), slotsAllowed, 0, "TRUE"
  ]);

  return { ok:true, code, expiresAt, slotsAllowed };
}

function vipAdminListCodes(adminPass){
  vipInit_();
  const a = checkAdmin_(adminPass); if(!a.ok) return a;

  const sh = sh_(SHEET_CODES);
  const values = sh.getDataRange().getValues();
  if(values.length < 2) return { ok:true, rows:[], totalAllowed:0, totalCreated:0 };

  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  const rows = [];
  let totalAllowed = 0;
  let totalCreated = 0;

  for(let i=1;i<values.length;i++){
    const code = String(values[i][idx.code]||"").trim().toUpperCase();
    const slotsAllowed  = Number(values[i][idx.slotsAllowed]||0);
    const slotsAssigned = Number(values[i][idx.slotsAssigned]||0);
    const expiresAt = values[i][idx.expiresAt];
    const active = String(values[i][idx.isActive]||"TRUE").toUpperCase() !== "FALSE";

    totalAllowed += slotsAllowed;
    totalCreated += slotsAssigned;

    rows.push({
      code,
      slotsAllowed,
      slotsAssigned,
      expiresAt,
      expired: expiresAt ? isExpired_(expiresAt) : true,
      active
    });
  }

  // últimos primeiro
  rows.reverse();

  return { ok:true, rows, totalAllowed, totalCreated };
}

// Atribui slots do pool (code vazio) para um código até atingir slotsAllowed.
// Retorna quantos criou/atribuiu.
function vipAdminAssignSlotsToCode(adminPass, code){
  vipInit_();
  const a = checkAdmin_(adminPass); if(!a.ok) return a;

  code = String(code||"").trim().toUpperCase();
  const chk = validateCode_(code);
  if(!chk.ok) return chk;

  const codeRow = findCodeRow_(code);
  const shC = codeRow.sh;
  const idxC = codeRow.idx;
  const rowIndexC = codeRow.rowIndex;

  const allowed = Number(codeRow.row[idxC.slotsAllowed]||0);
  const assigned = Number(codeRow.row[idxC.slotsAssigned]||0);

  if(assigned >= allowed){
    return { ok:true, code, allowed, assigned, added:0, msg:"Já está no limite desse código." };
  }

  const need = allowed - assigned;

  const vip = sh_(SHEET_VIP);
  const values = vip.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  // pool candidates: code vazio
  const pool = [];
  for(let i=1;i<values.length;i++){
    const slotCode = String(values[i][idx.code]||"").trim();
    if(!slotCode){
      pool.push(i+1);
    }
  }

  if(pool.length < need){
    return { ok:false, error:`Pool insuficiente. Precisa ${need} slots livres no pool, mas tem ${pool.length}. Aumente os slots gerais.` };
  }

  // atribui os primeiros "need"
  for(let k=0;k<need;k++){
    const r = pool[k];
    vip.getRange(r, idx.code+1).setValue(code);
    vip.getRange(r, idx.updatedAt+1).setValue(now_());
  }

  // atualiza contador do código
  const newAssigned = assigned + need;
  shC.getRange(rowIndexC, idxC.slotsAssigned+1).setValue(newAssigned);

  return { ok:true, code, allowed, assigned:newAssigned, added:need };
}

// Remove X slots do código: devolve pro pool (limpa dados e code="").
// Só remove slots do código que estejam LIVRE (para não apagar ocupados).
function vipAdminUnassignSlotsFromCode(adminPass, code, removeCount){
  vipInit_();
  const a = checkAdmin_(adminPass); if(!a.ok) return a;

  code = String(code||"").trim().toUpperCase();
  removeCount = Math.max(0, parseInt(removeCount||0,10));
  if(!removeCount) return { ok:true, removed:0 };

  const codeRow = findCodeRow_(code);
  if(!codeRow) return { ok:false, error:"Código não encontrado." };

  const vip = sh_(SHEET_VIP);
  const values = vip.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  const candidates = [];
  for(let i=1;i<values.length;i++){
    const slotCode = String(values[i][idx.code]||"").trim().toUpperCase();
    const status = String(values[i][idx.status]||"").toUpperCase();
    if(slotCode===code && status==="LIVRE"){
      candidates.push(i+1);
    }
  }

  if(candidates.length < removeCount){
    return { ok:false, error:`Não dá pra tirar ${removeCount}. Livres nesse código: ${candidates.length}.` };
  }

  // devolve pro pool (limpa code e dados)
  for(let k=0;k<removeCount;k++){
    const r = candidates[candidates.length-1-k]; // de trás
    // limpa dados do slot
    vip.getRange(r, idx.status+1).setValue("LIVRE");
    vip.getRange(r, idx.nome+1, 1, 8).clearContent(); // nome..modelo + updatedAt
    vip.getRange(r, idx.code+1).setValue("");
    vip.getRange(r, idx.confirmed+1).setValue("FALSE");
    vip.getRange(r, idx.veiculo+1).setValue("NAO");
    vip.getRange(r, idx.updatedAt+1).setValue(now_());
  }

  // atualiza contador
  const assigned = Number(codeRow.row[codeRow.idx.slotsAssigned]||0);
  const newAssigned = Math.max(0, assigned - removeCount);
  codeRow.sh.getRange(codeRow.rowIndex, codeRow.idx.slotsAssigned+1).setValue(newAssigned);

  return { ok:true, removed:removeCount, assigned:newAssigned };
}

// ===================== Admin: Slots por código =====================
function vipAdminGetByCode(adminPass, code){
  vipInit_();
  const a = checkAdmin_(adminPass); if(!a.ok) return a;

  code = String(code||"").trim().toUpperCase();
  const chk = validateCode_(code);
  if(!chk.ok) return chk;

  const vip = sh_(SHEET_VIP);
  const values = vip.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  const rows = [];
  for(let i=1;i<values.length;i++){
    const slotCode = String(values[i][idx.code]||"").trim().toUpperCase();
    if(slotCode !== code) continue;

    const confirmed = String(values[i][idx.confirmed]||"").toUpperCase()==="TRUE";
    rows.push({
      slot: values[i][idx.slot],
      status: values[i][idx.status],
      nome: values[i][idx.nome],
      rg: values[i][idx.rg],
      cpf: values[i][idx.cpf],
      veiculo: values[i][idx.veiculo],
      placa: values[i][idx.placa],
      cor: values[i][idx.cor],
      modelo: values[i][idx.modelo],
      updatedAt: values[i][idx.updatedAt],
      code: slotCode,
      confirmed
    });
  }

  return { ok:true, rows, code };
}

function vipAdminClearSlot(adminPass, code, slotId){
  vipInit_();
  const a = checkAdmin_(adminPass); if(!a.ok) return a;

  code = String(code||"").trim().toUpperCase();
  slotId = String(slotId||"").trim();

  const vip = sh_(SHEET_VIP);
  const values = vip.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  let rowIndex=-1;
  for(let i=1;i<values.length;i++){
    const s = String(values[i][idx.slot]);
    const slotCode = String(values[i][idx.code]||"").trim().toUpperCase();
    if(s===slotId && slotCode===code){ rowIndex=i+1; break; }
  }
  if(rowIndex<0) return { ok:false, error:"Slot não encontrado nesse código." };

  vip.getRange(rowIndex, idx.status+1).setValue("LIVRE");
  vip.getRange(rowIndex, idx.nome+1, 1, 8).clearContent();
  vip.getRange(rowIndex, idx.veiculo+1).setValue("NAO");
  vip.getRange(rowIndex, idx.confirmed+1).setValue("FALSE");
  vip.getRange(rowIndex, idx.updatedAt+1).setValue(now_());

  return { ok:true };
}

function vipAdminConfirmSlot(adminPass, code, slotId){
  vipInit_();
  const a = checkAdmin_(adminPass); if(!a.ok) return a;

  code = String(code||"").trim().toUpperCase();
  slotId = String(slotId||"").trim();

  const vip = sh_(SHEET_VIP);
  const values = vip.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  let rowIndex=-1;
  for(let i=1;i<values.length;i++){
    const s = String(values[i][idx.slot]);
    const slotCode = String(values[i][idx.code]||"").trim().toUpperCase();
    if(s===slotId && slotCode===code){ rowIndex=i+1; break; }
  }
  if(rowIndex<0) return { ok:false, error:"Slot não encontrado nesse código." };

  const cell = vip.getRange(rowIndex, idx.confirmed+1);
  const current = String(cell.getValue()||"FALSE").toUpperCase()==="TRUE";
  cell.setValue(current ? "FALSE" : "TRUE");
  vip.getRange(rowIndex, idx.updatedAt+1).setValue(now_());

  return { ok:true, confirmed: !current };
}

// Exclui o slot (remove linha). Também decrementa slotsAssigned do código.
function vipAdminDeleteSlot(adminPass, code, slotId){
  vipInit_();
  const a = checkAdmin_(adminPass); if(!a.ok) return a;

  code = String(code||"").trim().toUpperCase();
  slotId = String(slotId||"").trim();

  const vip = sh_(SHEET_VIP);
  const values = vip.getDataRange().getValues();
  const headers = values[0].map(String);
  const idx = indexMap_(headers);

  let rowIndex=-1;
  for(let i=1;i<values.length;i++){
    const s = String(values[i][idx.slot]);
    const slotCode = String(values[i][idx.code]||"").trim().toUpperCase();
    if(s===slotId && slotCode===code){ rowIndex=i+1; break; }
  }
  if(rowIndex<0) return { ok:false, error:"Slot não encontrado nesse código." };

  vip.deleteRow(rowIndex);

  const codeRow = findCodeRow_(code);
  if(codeRow){
    const assigned = Number(codeRow.row[codeRow.idx.slotsAssigned]||0);
    codeRow.sh.getRange(codeRow.rowIndex, codeRow.idx.slotsAssigned+1).setValue(Math.max(0, assigned-1));
  }

  return { ok:true };
}

// ===================== utils =====================
function maskName_(name){
  name = String(name||"").trim();
  if(!name) return "";
  return name[0].toUpperCase() + " •••••";
}

// ===================== Router POST =====================
function doPost(e){
  vipInit_();

  let data = {};
  try { data = JSON.parse((e && e.postData && e.postData.contents) ? e.postData.contents : "{}"); }
  catch(err){ return json_({ ok:false, error:"JSON inválido" }); }

  const fn = data.fn;
  const p = data.payload || {};

  try{
    // public
    if(fn === "vipPublicGet") return json_(vipPublicGet(p.code));
    if(fn === "vipReserve")   return json_(vipReserve(p.code, p));

    // admin
    if(fn === "vipAdminSetGlobalSlotCount") return json_(vipAdminSetGlobalSlotCount(p.adminPass, p.total));
    if(fn === "vipAdminCreateOrUpdateCode") return json_(vipAdminCreateOrUpdateCode(p.adminPass, p.minutes, p.slotsAllowed));
    if(fn === "vipAdminListCodes")          return json_(vipAdminListCodes(p.adminPass));
    if(fn === "vipAdminAssignSlotsToCode")  return json_(vipAdminAssignSlotsToCode(p.adminPass, p.code));
    if(fn === "vipAdminUnassignSlotsFromCode") return json_(vipAdminUnassignSlotsFromCode(p.adminPass, p.code, p.removeCount));
    if(fn === "vipAdminGetByCode")          return json_(vipAdminGetByCode(p.adminPass, p.code));
    if(fn === "vipAdminClearSlot")          return json_(vipAdminClearSlot(p.adminPass, p.code, p.slotId));
    if(fn === "vipAdminConfirmSlot")        return json_(vipAdminConfirmSlot(p.adminPass, p.code, p.slotId));
    if(fn === "vipAdminDeleteSlot")         return json_(vipAdminDeleteSlot(p.adminPass, p.code, p.slotId));

    return json_({ ok:false, error:"Função inválida: " + fn });

  }catch(err){
    return json_({ ok:false, error:String(err && err.message ? err.message : err) });
  }
}
